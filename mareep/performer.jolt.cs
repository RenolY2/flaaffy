
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace arookas.Jolt {

	[Performer(Action.Jolt)]
	class JoltPerformer : MidiReader, IPerformer {

		string mInput, mOutput;

		StreamWriter mWriter;

		Track mRootTrack;
		Track[] mChannelTracks;

		public JoltPerformer() {
			mRootTrack = new Track();
			mChannelTracks = new Track[16];
			for (var i = 0; i < 16; ++i) {
				mChannelTracks[i] = new Track();
			}
		}

		public void LoadParams(string[] arguments) {
			var cmdline = new aCommandLine(arguments);
			aCommandLineParameter param;

			param = mareep.GetLastCmdParam(cmdline, "-input");

			if (param == null) {
				mareep.WriteError("Missing -input parameter.");
			} else if (param.Count < 1) {
				mareep.WriteError("Bad -input parameter.");
			}

			mInput = param[0];

			param = mareep.GetLastCmdParam(cmdline, "-output");

			if (param == null) {
				mareep.WriteError("Missing -output parameter.");
			} else if (param.Count < 1) {
				mareep.WriteError("Bad -output parameter.");
			}

			mOutput = param[0];
		}

		public void Perform() {
			using (var instream = mareep.OpenFile(mInput)) {
				LoadMidi(instream);

				if (Format == 2) {
					mareep.WriteError("Format 2 MIDIs are not supported.");
				}

				LoadTracks();
			}

			using (var outstream = mareep.CreateFile(mOutput)) {
				mWriter = new StreamWriter(outstream, Encoding.UTF8);
				mWriter.WriteLine();
				mWriter.WriteLine("# this file was generated by mareep");
				mWriter.WriteLine("# input file: {0}", Path.GetFileName(mInput));
				mWriter.WriteLine();

				WriteSeparator();
				mWriter.WriteLine();
				mWriter.WriteLine("ROOT_TRACK_BEGIN:");
				for (var i = 0; i < 16; ++i) {
					if (mChannelTracks[i].Count == 0) {
						continue;
					}

					mWriter.WriteLine("opentrack {0}, @TRACK_{0}_BEGIN", i);
				}
				mWriter.WriteLine();
				mWriter.WriteLine("timebase {0}h", Division);
				mWriter.WriteLine("load rpitch, 2b");
				mWriter.WriteLine();
				mRootTrack.Write(mWriter);
				mWriter.WriteLine("ROOT_TRACK_END:");
				mWriter.WriteLine();

				for (var i = 0; i < 16; ++i) {
					if (mChannelTracks[i].Count == 0) {
						continue;
					}

					WriteSeparator();
					mWriter.WriteLine();
					mWriter.WriteLine("TRACK_{0}_BEGIN:", i);
					mWriter.WriteLine("synccpu 0");
					mChannelTracks[i].Write(mWriter);
					mWriter.WriteLine("TRACK_{0}_END:", i);
					mWriter.WriteLine();
				}

				mWriter.Flush();
			}
		}

		void LoadTracks() {
			EventInfo ev;
			var duration = 0L;

			for (var i = 0; i < TrackCount; ++i) {
				GotoTrack(i);
				var time = 0L;

				while (ReadEvent(out ev)) {
					time += ev.delta;

					switch (ev.type) {
						case EventType.NoteOn: ReadNoteOn(time, ev); break;
						case EventType.NoteOff: ReadNoteOff(time, ev); break;
						case EventType.ControlChange: ReadControlChange(time, ev); break;
						case EventType.ProgramChange: ReadProgramChange(time, ev); break;
						case EventType.PitchWheel: ReadPitchWheel(time, ev); break;
						case EventType.Meta: {
							switch (ev.metatype) {
								case MetaEventType.Tempo: ReadTempo(time, ev); break;
								case MetaEventType.EndOfTrack: {
									if (duration < time) {
										duration = time;
									}
									break;
								}
							}
							break;
						}
					}
				}
			}

			mRootTrack.AddEvent(duration, "finish");

			for (var i = 0; i < 16; ++i) {
				if (mChannelTracks[i].Count == 0) {
					continue;
				}

				mChannelTracks[i].AddEvent(duration, "finish");
			}
		}

		void ReadNoteOn(long time, EventInfo ev) {
			if (ev.velocity > 0) {
				mChannelTracks[ev.channel].AddNoteOn(time, ev.key, ev.velocity);
			} else {
				ReadNoteOff(time, ev);
			}
		}
		void ReadNoteOff(long time, EventInfo ev) {
			mChannelTracks[ev.channel].AddNoteOff(time, ev.key);
		}
		void ReadControlChange(long time, EventInfo ev) {
			switch (ev.controller) {
				case 7: mChannelTracks[ev.channel].AddEvent(time, "timedparam 0, {0}s", ev.value); break;
				case 10: mChannelTracks[ev.channel].AddEvent(time, "timedparam 3, {0}s", ((ev.value - 64) * 2)); break;
				case 32: mChannelTracks[ev.channel].AddEvent(time, "load rbank, {0}b", ev.value); break;
			}
		}
		void ReadProgramChange(long time, EventInfo ev) {
			var program = ev.program;
			if (ev.channel == 10) {
				program = (228 + (program % 12));
			}
			mChannelTracks[ev.channel].AddEvent(time, "load rprogram, {0}b", program);
		}
		void ReadPitchWheel(long time, EventInfo ev) {
			mChannelTracks[ev.channel].AddEvent(time, "timedparam 1, {0}h", (ev.pitch - 8192));
		}
		void ReadTempo(long time, EventInfo ev) {
			mRootTrack.AddEvent(time, "tempo {0}h", (60000000 / ev.tempo));
		}

		void WriteSeparator() {
			mWriter.WriteLine("# ---------------------------------------------");
		}
		
	}

	class Track {

		List<Event> mEvents;
		int[] mActiveNotes;

		public int Count { get { return mEvents.Count; } }
		public long Duration { get { return (mEvents.Count > 0 ? mEvents[mEvents.Count - 1].Time : 0); } }

		public Track() {
			mEvents = new List<Event>();
			mActiveNotes = new int[7];
			for (var i = 0; i < 7; ++i) {
				mActiveNotes[i] = -1;
			}
		}

		public bool AddNoteOn(int key, int velocity) {
			return AddNoteOn(Duration, key, velocity);
		}
		public bool AddNoteOn(long time, int key, int velocity) {
			for (var i = 0; i < mActiveNotes.Length; ++i) {
				if (mActiveNotes[i] < 0 || mActiveNotes[i] == key) {
					mActiveNotes[i] = key;
					AddEvent(time, "noteon {0}, {1}, {2}", mareep.ConvertKey(key), velocity, (i + 1));
					return true;
				}
			}
			return false;
		}
		public bool AddNoteOff(int key) {
			return AddNoteOff(Duration, key);
		}
		public bool AddNoteOff(long time, int key) {
			for (var i = 0; i < 7; ++i) {
				if (mActiveNotes[i] == key) {
					mActiveNotes[i] = -1;
					AddEvent(time, "noteoff {0}", (i + 1));
					return true;
				}
			}
			return false;
		}
		public void AddEvent(string message) {
			AddEvent(Duration, message);
		}
		public void AddEvent(long time, string message) {
			AddEvent(new Event(time, message));
		}
		public void AddEvent(string format, params object[] arguments) {
			AddEvent(Duration, format, arguments);
		}
		public void AddEvent(long time, string format, params object[] arguments) {
			AddEvent(new Event(time, format, arguments));
		}
		void AddEvent(Event ev) {
			int i;
			for (i = 0; i < mEvents.Count; ++i) {
				if (mEvents[i].Time > ev.Time) {
					break;
				}
			}
			mEvents.Insert(i, ev);
		}

		public void Write(TextWriter writer) {
			var time = 0L;
			foreach (var ev in mEvents) {
				WriteWait(ev.Time - time, writer);
				ev.Write(writer);
				time = ev.Time;
			}
		}
		void WriteWait(long delta, TextWriter writer) {
			while (delta > 0) {
				var delay = System.Math.Min(delta, 0xFFFFFF);
				if (delay > 0xFFFF) {
					writer.WriteLine("wait {0}q", delay);
				} else if (delay > 0xFF) {
					writer.WriteLine("wait {0}h", delay);
				} else {
					writer.WriteLine("wait {0}b", delay);
				}
				delta -= delay;
			}
		}

		class Event {

			long mTime;
			string mText;

			public long Time { get { return mTime; } }

			public Event(long time, string message) : this(time, "{0}", message) { }
			public Event(long time, string format, params object[] arguments) {
				mTime = time;
				mText = String.Format(format, arguments);
			}

			public void Write(TextWriter writer) {
				writer.WriteLine(mText);
			}

		}

	}

}
